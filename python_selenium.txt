

download webdriver from :

https://chromedriver.chromium.org/downloads

#########

####Webdriver :

1) Selenium python bindings provides a simple API to write functional/acceptance tests using selenium webdriver
2) Through selenium API , functionalities of selenium webdriver can be accessed
3) Selenium requires driver to interface with to interface with the browser.

####classes :

1)Keys - The Keys class provide keys in the keyboard like RETURN, F1, ALT etc
2)By - The By class is used to locate elements within a document.
3)Driver.get - method will navigate to the URL with URL as the parameter passed
4)Assert - confirm , compare two parameters.
5)find elements - WebDriver offers a number of ways to find elements using the find_element method
6)selenium.webdriver.common.keys - send text as the parameter to the input fields on webpage. For safe side , any text fields which might be having values in it needs to be cleared
7)quit , close - The quit method will exit the browser whereas close will close one tab, but if just one tab was open, by default most browsers will exit entirely.

##### unitest

1) unittest.TestCase - The test case class is inherited from unittest.TestCase. Inheriting from the TestCase class is the way to tell unittest module that this is a test case.
2)setUp - method is part of initialization. This method will get called before every test function which you are going to write in this test case class.

3)*WebDriver will wait until the page has fully loaded (that is, the “onload” event has fired) before returning control to your test or script. Be aware that if your page uses a lot of AJAX on load then WebDriver may not know when it has completely loaded.

4)assertion - To ensure that some results are found.

5)tearDown -  method will get called after every test method. This is a place to do all cleanup actions.

####Selenium with remote WebDriver


######Interacting with the page

below are the are the ways we can use to find elements on webpage:

<input type="text" name="passwd" id="passwd-id" />

element = driver.find_element(By.ID, "passwd-id")
element = driver.find_element(By.NAME, "passwd")
element = driver.find_element(By.XPATH, "//input[@id='passwd-id']")
element = driver.find_element(By.CSS_SELECTOR, "input#passwd-id")


**XPATH : You should also be careful when using XPATH in WebDriver. If there’s more than one element that matches the query, then only the first will be returned. If nothing can be found, a NoSuchElementException will be raised.

**Remember to clear the text field contens

####drop down :

select tag --

from selenium.webdriver.support.ui import Select
select = Select(driver.find_element(By.NAME, 'name'))
select.select_by_index(index)
select.select_by_visible_text("text")
select.select_by_value(value)

**deselect options 
select = Select(driver.find_element(By.ID, 'id'))
select.deselect_all()


**default selected options
select = Select(driver.find_element(By.XPATH, "//select[@name='name']"))
all_selected_options = select.all_selected_options

**To get all available options:
options = select.options


**driver.find_element_by_id("submit").click()
or
element.submit()

***element isn’t in a form, then the NoSuchElementException


#### Drag and drop
You can use drag and drop, either moving an element by a certain amount, or on to another element:

element = driver.find_element(By.NAME, "source")
target = driver.find_element(By.NAME, "target")

***ActionChains
from selenium.webdriver import ActionChains

action_chains = ActionChains(driver)
action_chains.drag_and_drop(element, target).perform()

####Moving between windows and frames

driver.switch_to_window("windowName")

<a href="somewhere.html" target="windowName">Click here to open a new window</a>



***Iterate over open windows

for handle in driver.window_handles:
    driver.switch_to_window(handle)


*** frame to frame

You can also swing from frame to frame (or into iframes):

driver.switch_to_frame("frameName")

***Access subframes  by separating the path with a dot

driver.switch_to_frame("frameName.0.child")



***Once we are done with working on frames, we will have to come back to the parent frame which can be done using:

driver.switch_to.default_content()



***pop up 

alert = driver.switch_to.alert

####driver.get("http://www.example.com")

driver.forward()
driver.back()


#####Page object 

**A page object represents an area where the test interacts within the web application user interface.

** This technique helps build a separation between the test code and the actual code that interacts with the web page.

i.e separate .py file for handling webpage with locators , similarly separate py file for elements and  , separate file for ACTUAL TEST.



###Waits :

**Waiting provides some slack between actions performed - mostly locating an element or any other operation with the element

**Due to AJAX techniques being used widely. When a page is loaded by the browser, the elements within that page may load at different time intervals

**This makes locating elements difficult: if an element is not yet present in the DOM, a locate function will raise an ElementNotVisibleException exception. 


###Explicit Waits

**wait for a certain condition to occur before proceeding further in the code


**WebDriverWait calls the ExpectedCondition every 500 milliseconds until it returns success

** If no element is found in that time, a TimeoutException is thrown

** ExpectedCondition will return true (Boolean) in case of success or not null if it fails to locate an element


eg :
from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC

driver = webdriver.Firefox()
driver.get("http://somedomain/url_that_delays_loading")
try:
    element = WebDriverWait(driver, 10).until(
        EC.presence_of_element_located((By.ID, "myDynamicElement"))
    )
finally:
    driver.quit()



****Some of the expected conditions frequently used

title_is
title_contains
presence_of_element_located
visibility_of_element_located
visibility_of
presence_of_all_elements_located
text_to_be_present_in_element
text_to_be_present_in_element_value
frame_to_be_available_and_switch_to_it
invisibility_of_element_located
element_to_be_clickable
staleness_of
element_to_be_selected
element_located_to_be_selected
element_selection_state_to_be
element_located_selection_state_to_be
alert_is_present

***Wecan also create custom wait conditions
You may also consider using polling2 library which you need to install separately.



#####Implicit Waits

***An implicit wait tells WebDriver to poll the DOM for a certain amount of time when trying to find any element (or elements) not immediately available. The default setting is 0 (zero). Once set, the implicit wait is set for the life of the WebDriver object.


from selenium import webdriver

driver = webdriver.Firefox()
driver.implicitly_wait(10) # seconds
driver.get("http://somedomain/url_that_delays_loading")
myDynamicElement = driver.find_element_by_id("myDynamicElement")





######Locating Elements

**find_element

**find_elements

Above methods will return a list


**ID

-the first element with a matching id attribute will be returned. If no element has a matching id attribute, a NoSuchElementException will be raised.

** Name

--the first element with a matching name attribute will be returned. If no element has a matching name attribute, a NoSuchElementException will be raised.


** Hyperlink

--the first element with the link text matching the provided value will be returned. If no element has a matching link text attribute, a NoSuchElementException will be raised.

**Tag name

--the first element with the given tag name will be returned. If no element has a matching tag name, a NoSuchElementException will be raised.

**Class Name

--the first element with the matching class name attribute will be returned. If no element has a matching class name attribute, a NoSuchElementException will be raised.



**CSS selector

-- the first element matching the given CSS selector will be returned. If no element matches the provided CSS selector, a NoSuchElementException will be raised


##XPath 

--XPath is when you don’t have a suitable id or name attribute for the element you wish to locate

-absolute
-relative

***Absolute XPaths contain the location of all elements from the root (html) and as a result are likely to fail with only the slightest adjustment to the application

***By finding a nearby element with an id or name attribute (ideally a parent element) you can locate your target element based on the relationship. This is much less likely to change and can make your tests more robust.
